type new_batch = {
  resource:string,
  reward_amount:tez
};

type new_batch_set = big_map<string, tez>;

type storage = {
    batch_pool: big_map<string, tez>,
};

type reveal = {
  hashable: bytes,
  message: ((_u:unit) => list<operation>)
};

type parameter = 
|  ["Add_batch", new_batch_input_struct];

type return_ = [list<operation>, storage];

let new_batch_: new_batch = ([p, s] : [bytes, storage]) : return_ => {
    let new_batch_ : new_batch = {resource: string, reward_amount: tez};
    let s_ = {...s, batch_pool: updated_map};
    return [(list([]) as list<operation>), s_];
};

let reveal = ([p, s]: [reveal, storage]) : return_ => {
  if (!s.unused) {
    failwith("This contract has already been used.");
  };

  let new_batch_ : new_batch =
    match (Big_map.find_opt(resource, s.batch_pool), {
    Some: b => b,
    None: () =>
       (failwith("Resource has not been submitted yet.") as new_batch)
    });
}

const main = (params: parameter, stor: storage) : [ list<operation> , storage ] => {
 return [
   (match (action, {
    Add_batch: (resource, reward_amount) => new_batch(resource, reward_amount)
    }))
  ]
};
